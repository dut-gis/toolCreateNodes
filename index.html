<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <script src="p5.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GIS Tool create nodes</title>
    <style>
        canvas{
            padding-left: 0;
            padding-right: 0;
            margin-left: auto;
            margin-right: auto;
            display: block;
        }
        div{
            display:flex;
            justify-content:center;
            align-items:center;
        }
        b{
            margin-left: 14px;
            margin-right: 6px;
        }
        button{
            margin: 0px 8px 0px 8px;
        }
    </style>
</head>
<body>
    <div style="padding: 8px 8px;">
        <b>Node size: </b>
        <input type="range" min="4" max="15" value="10" id="nodeSize">
        <b>Node color: </b>
        <input type="color" id="nodeColor" value="#241ae8">
        <b>Node click color: </b>
        <input type="color" id="nodeAddPathColor" value="#ff003c">
        <b>Line color: </b>
        <input type="color" id="lineColor" value="#bcc418">
    </div>
    <div style="padding: 8px 8px;">
        <button onclick=objToJson()>LOG JSON</button>
        <button onclick="download('map.json', 'text/plain')">CREATE FILE</button>
        <a href="" id="a"></a> 
    </div>
    <script>
        var a = document.getElementById("a");
        var rangeNodeSize = document.getElementById("nodeSize");
        var nodeColor = document.getElementById("nodeColor");
        var nodeAddPathColor = document.getElementById("nodeAddPathColor");
        var lineColor = document.getElementById("lineColor");
        let img;
        nodes = [];
        stackHistory = [];
        nodeBegin = null;

        function objToJson(){
            console.log(JSON.stringify(nodes));
        }

        function download(name, type) {
            var file = new Blob([JSON.stringify(nodes)], {type: type});
            a.href = URL.createObjectURL(file);
            a.download = name;
            a.text = "DOWNLOAD";
        }

        function preload() {
            img = loadImage('map.jpg');
        }
        // width = 1000;
        // height = 1000;

        function setup() {
            createCanvas(1000+0.01, 1000+0.01);
            document.addEventListener('keydown', function(event) {
                if (event.ctrlKey && event.key === 'z') {
                    if(stackHistory.length>0){
                        h = stackHistory.pop();
                        if(h.type=="NODE"){
                            nodes.pop();
                        }else
                        if(h.type=="PATHBEGIN"){
                            nodeBegin=null;
                        }else
                        if(h.type=="PATH"){
                            nodes[h.nodeIds[0]].paths.pop();
                            nodes[h.nodeIds[1]].paths.pop();
                        }else
                        if(h.type=="DELETENODE"){
                            unDeleteNode(h.node);
                        }
                    }else{
                        alert("STUPID");
                    }
                    
                }
                if (event.shiftKey) {
                    nodeBegin = null;
                }
                if (event.ctrlKey && event.key === 'x') {
                    id = nodeBegin;
                    nodeBegin = null;
                    deleteNode(nodes[id]);
                }
            });
        }

        function draw() {
            nodeSize = rangeNodeSize.value;
            image(img, 0,0,img.width/2, img.height/2);

            strokeWeight(1);
            stroke(lineColor.value);
            fill(nodeColor.value);

            //draw paths
            try{
                nodes.forEach((e,index) => {
                    e.paths.forEach(e2 => {
                        line(e.posX,e.posY,nodes[e2].posX,nodes[e2].posY);
                    });
                });
            }catch(e){
            }

            //draw line if function is add_path
            if(nodeBegin!=null){
                line(nodes[nodeBegin].posX,nodes[nodeBegin].posY,mouseX,mouseY);
            }

            //draw nodes
            stroke(color(0));
            nodes.forEach((e,index) => {
                if(nodeBegin!=null&&e.id==nodeBegin){
                    fill(nodeAddPathColor.value);
                    ellipse(e.posX,e.posY,nodeSize,nodeSize);
                    fill(nodeColor.value);
                }else{
                    fill(nodeColor.value);
                    ellipse(e.posX,e.posY,nodeSize,nodeSize);
                    fill(255, 26, 26);
                    text(e.id, e.posX,e.posY);
                }
            });
            fill(nodeColor.value);
            ellipse(mouseX,mouseY,nodeSize,nodeSize);

            noFill();
            strokeWeight(4);
            rect(2, 2, width-5, height-5);
        }

        function mouseClicked() {
            nodeSize = rangeNodeSize.value;
            //Check node inside canvas
            if(mouseX<0||mouseY<0||mouseX>width||mouseY>height) return ;

            //Init node
            node = {
                id: nodes.length,
                posX: mouseX,
                posY: mouseY,
                paths: []      
            };

            a.text = "";

            //Check function is add path
            if(nodeBegin==null){
                for(let e of nodes){
                    if(getNodeDistance(e,node)<=nodeSize*2){
                        print("Switch to add path function");
                        nodeBegin = e.id;
                        stackHistory.push({
                            type: "PATHBEGIN",
                            nodeIds: []
                        })
                        return 1;
                    }
                }
            }else{
                for(let e of nodes){
                    if(getNodeDistance(e,node)<=nodeSize*2){
                        if(e.id==nodeBegin){
                            print("Switch to add node function");
                            nodeBegin = null;
                        }else{
                            if(checkIsHasPath(e,nodeBegin)){
                                print("remove path");
                                e.paths = e.paths.filter(v =>{
                                    return v!=nodeBegin;
                                });
                                nodes[nodeBegin].paths = nodes[nodeBegin].paths.filter(v=>{
                                    return v!=e.id;
                                });
                            }else{
                                print("Add path")
                                e.paths.push(nodeBegin);
                                nodes[nodeBegin].paths.push(e.id);
                                stackHistory.push({
                                    type: "PATH",
                                    nodeIds: [e.id,nodes[nodeBegin].id]
                                })
                            }
                        }
                        return 1;
                    }
                }
            }
            console.log("Create node at: " + mouseX +", " +mouseY );
            nodes.push(node);
            stackHistory.push({
                type: "NODE",
                nodeIds: [node.id]
            })
        }

        function getNodeDistance(a,b){
                distance = Math.sqrt(Math.abs(Math.pow(b.posX-a.posX,2)+Math.pow(b.posY-a.posY,2)));
                return distance;
        }

        function checkIsHasPath(node, path){
            return node.paths.includes(path);
        }

        function deleteNode(node){
            stackHistory.push({
                type: "DELETENODE",
                node: node
            })
            //Delete node and path relative to that node
            node.paths.forEach(e => {
                nodes[e].paths = nodes[e].paths.filter(v =>{
                    return v!=node.id;
                });
            });
            //Update path
            for(i=0;i<nodes.length;i++){
                if(nodes[i].id>node.id) nodes[i].id-=1;
                if(i!=node.id){
                    for(j=0;j<nodes[i].paths.length;j++){
                        if(nodes[i].paths[j]>node.id) nodes[i].paths[j]-=1;
                    }
                }
            }
           
            nodes.splice(node.id,1);

        }

        function unDeleteNode(node){
            nodes.splice(node.id,0,node);

            node.paths.forEach(e => {
                nodes[e].paths.push(node.id);
            });

            for(i=node.id+1;i<nodes.length;i++){
                if(i>node.id) nodes[i].id+=1;
                if(i!=node.id){
                    for(j=0;j<nodes[i].paths.length;j++){
                        if(nodes[i].paths[j]>=node.id) nodes[i].paths[j]+=1;
                    }
                }
            }
        }

    </script>
</body>
</html>